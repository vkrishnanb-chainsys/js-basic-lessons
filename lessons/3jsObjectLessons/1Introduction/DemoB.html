<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>
</head>
<body>
    <script>
        var cody = new Object();
        cody.living = true;
        cody.age = 33;
        cody.gender = 'male';
        cody.getGender = function () { return cody.gender; };
        console.log(cody.getGender()); // logs 'male'
    </script>

    <script>
        var myObject = new Object(); // produces an Object() object
        myObject['0'] = 'f';
        myObject['1'] = 'o';
        myObject['2'] = 'o';
        console.log(myObject); // logs Object { 0="f", 1="o", 2="o"}
        var myString = new String('foo'); // produces a String() object
        console.log(myString); // logs foo { 0="f", 1="o", 2="o"}
    </script>
    <script>
        // define Person constructor function in order to create 
        //custom Person() objects later
        var Person = function (living, age, gender) {
            this.living = living;
            this.age = age;
            this.gender = gender;
            this.getGender = function () { return this.gender; };
        };
        // instantiate a Person object and store it in the cody variable
        var cody = new Person(true, 33, 'male');
        console.log(cody);
        ///* The String() constructor function below,
        // * having been defined by JavaScript, has the same pattern.
        //Because the string constructor is native to JavaScript,
        //all we have to do to get a string instance is instantiate it.
        //But the pattern is the same whether we use native
        //constructors like String() or user-defined constructors like Person().
        //*/
        //// instantiate a String object stored in the myString variable
        //var myString = new String('foo');
        //console.log(myString);
    </script>
    <script>
        // create a codyA object using the Object() constructor
        var codyA = new Object();
        codyA.living = true;
        codyA.age = 33;
        codyA.gender = 'male';
        codyA.getGender = function () { return codyA.gender; };
        console.log(codyA); // logs Object {living=true, age=33, gender="male", ...}
        /* The same cody object is created below, but instead of using the native Object()
        constructor to create a one-off cody, we first define our own Person() constructor that can
        create a cody object (and any other Person object we like) and then instantiate it with
        "new". */
        var Person = function (living, age, gender) {
            this.living = living;
            this.age = age;
            this.gender = gender;
            this.getGender = function () { return this.gender; };
        };
        // logs Object {living=true, age=33, gender="male", ...}
        var codyB = new Person(true, 33, 'male');
        console.log(codyB);
    </script>
    <script>
        // instantiate an instance for each native constructor using the new keyword
        var myNumber = new Number(23);
        var myString = new String('male');
        var myBoolean = new Boolean(false);
        var myObject = new Object();
        var myArray = new Array('foo', 'bar');
      
        var myFunction = new Function("x", "y", "return x*y");
        var myDate = new Date();
        var myRegExp = new RegExp('\bt[a-z]+\b');
        var myError = new Error('Crap!');
        // log/verify which constructor created the object
        console.log(myNumber.constructor); // logs Number()
        console.log(myString.constructor); // logs String()
        console.log(myBoolean.constructor); // logs Boolean()
        console.log(myObject.constructor); // logs Object()
        console.log(myArray.constructor); //logs Array(), in modern browsers
        console.log(myFunction.constructor); // logs Function()
        console.log(myDate.constructor); // logs Date()
        console.log(myRegExp.constructor); // logs RegExp()
        console.log(myError.constructor); // logs Error()
    </script>
</body>
</html>